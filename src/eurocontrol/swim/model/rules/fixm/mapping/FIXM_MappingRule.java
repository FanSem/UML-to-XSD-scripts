/**
 *
##########################################################################
##########################################################################

Copyright (c) 2012, EUROCONTROL
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright 
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of EUROCONTROL nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

##########################################################################
##########################################################################
*/

package eurocontrol.swim.model.rules.fixm.mapping;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;

import org.sparx.Attribute;
import org.sparx.Collection;
import org.sparx.Connector;
import org.sparx.Element;
import org.sparx.Package;
import org.sparx.TaggedValue;

import eurocontrol.swim.model.gui.common.EAEventManager;
import eurocontrol.swim.model.rules.common.AbstractMappingRule;
import eurocontrol.swim.model.sparx.EAConnection;
import eurocontrol.swim.model.util.SparxUtilities;
import eurocontrol.swim.model.util.constants.FIXMConstants;

/**
 * @author hlepori
 */
public class FIXM_MappingRule extends AbstractMappingRule implements FIXMConstants {

    /**
     * 
     */
    protected final int SIMPLE_TYPE = 0;
    protected final int COMPLEX_TYPE_WITH_SIMPLE_CONTENT = 1;
    protected final int COMPLEX_TYPE_WITH_COMPLEX_CONTENT = 2;
    protected final int COMPLEX_TYPE_WITH_NO_CONTENT_AND_ATTRIBUTES = 3;
    protected final int COMPLEX_TYPE_WITH_NO_CONTENT_AND_ELEMENTS = 4;
    
   
    
    /**
     * List storing the name of the XSD files generated by the script
     */
    protected ArrayList _listOfFxXSDFiles = new ArrayList();
    protected ArrayList _listOfBaseXSDFiles = new ArrayList();
    
    /**
     * Attributes storing the NamespacePrefix and Namespace during the generation process
     */
    protected String _currentNamespacePrefix;
    protected String _currentNamespace;
    
    /**
     * 
     */
    public FIXM_MappingRule(Package targetPackage) throws IOException {
        super(targetPackage);
        setDefaultValues();
        initXSDFileProperties();
    }
    
    /* (non-Javadoc)
     * @see eurocontrol.swim.model.rules.AbstractMappingRule#getOutputFile()
     */
    public String getOutputFile() {
        return null;
    }
    
    /* (non-Javadoc)
     * @see eurocontrol.swim.model.rules.AbstractMappingRule#initXSDFileProperties()
     */
    protected void initXSDFileProperties() {
        //super.initXSDFileProperties();        
        _targetNamespacePrefix = FIXM_DEFAULT_TARGET_NAMESPACE_PREFIX;
        _targetNamespace = FIXM_DEFAULT_TARGET_NAMESPACE;        
        _elementFormDefault = "qualified";
        _attributeFormDefault = "qualified";   
    }
    
    /* (non-Javadoc)
     * @see eurocontrol.swim.model.rules.AbstractMappingRule#generateXSD()
     */
    public void generateXSD() throws IOException {
            
        // Generate the list of names of the various XSD file created. This is required upfront to manage properly the inclusioon of "import" element  
        generateListOfFileNames(_targetPackage.GetPackages());
        
        // Generate the XSD files defining the FIXS constructs 
        generateXSDForPackages(_targetPackage.GetPackages());
        
        // Create the file base.xsd that wrap all base_xxx.xsd files
        generateBaseXSDFile(); 
        
        // Create the file fx.xsd that wrap all fx_xxx.xsd files
        generateFxXSDFile();        
    }
    

    /**
     * 
     * @param subPackages
     * @throws IOException
     */
    public void generateListOfFileNames(Collection subPackages) throws IOException 
    {
        for (Iterator iter = subPackages.iterator();iter.hasNext();)
        {
            Package subPackage = (Package) iter.next();
            generateFileName(subPackage);
            generateListOfFileNames(subPackage.GetPackages());
        }
    }
    
    /**
     * 
     * @param subPackage
     * @throws IOException
     */
    public void generateFileName(Package subPackage) throws IOException 
    {
            
        if(subPackage.GetElements().GetCount()==0)
            return;
        
        String packageName = subPackage.GetName();
        String fileName = null;
        
        if(SparxUtilities.belongsToPackage(subPackage,FIXM_GUID_PACKAGE_BASE))
        {
            fileName = FIXM_BASE_TARGET_NAMESPACE_PREFIX + packageName + "." + XSD_DEFAULT_TARGET_NAMESPACE_PREFIX;
            _listOfBaseXSDFiles.add(fileName);
        }
        else if (SparxUtilities.belongsToPackage(subPackage,FIXM_GUID_PACKAGE_CORE))
        {
            fileName = FIXM_DEFAULT_TARGET_NAMESPACE_PREFIX + packageName + "." + XSD_DEFAULT_TARGET_NAMESPACE_PREFIX;
            _listOfFxXSDFiles.add(fileName);
        }          
    }
    
    /**
     * 
     * @param subPackages
     * @throws IOException
     */
    public void generateXSDForPackages(Collection subPackages) throws IOException 
    {
        for (Iterator iter = subPackages.iterator();iter.hasNext();)
        {
            Package subPackage = (Package) iter.next();
            generateXSDForPackage(subPackage);
            generateXSDForPackages(subPackage.GetPackages());
        }
    }
    
    
    /**
     * 
     * @param myPackage
     * @throws IOException
     */
    public void generateXSDForPackage(Package subPackage) throws IOException 
    {
            
        if(subPackage.GetElements().GetCount()==0)
            return;
        
        String packageName = subPackage.GetName();
        String fileName = null;
        
        if(SparxUtilities.belongsToPackage(subPackage,FIXM_GUID_PACKAGE_BASE))
        {
            _currentNamespacePrefix=FIXM_BASE_TARGET_NAMESPACE_PREFIX;
            _currentNamespace=FIXM_BASE_TARGET_NAMESPACE;
            fileName = _currentNamespacePrefix + packageName + "." + XSD_DEFAULT_TARGET_NAMESPACE_PREFIX ;
        }
        else if (SparxUtilities.belongsToPackage(subPackage, FIXM_GUID_PACKAGE_CORE))
        {
            _currentNamespacePrefix=FIXM_DEFAULT_TARGET_NAMESPACE_PREFIX;
            _currentNamespace=FIXM_DEFAULT_TARGET_NAMESPACE;
            fileName = _currentNamespacePrefix + packageName + "." + XSD_DEFAULT_TARGET_NAMESPACE_PREFIX;
        }             
   
        initXSDFile("./output/" + fileName);           
        
        org.w3c.dom.Element xsdRoot = createRootForPackage(subPackage);
        
        if(_currentNamespacePrefix.equals(FIXM_BASE_TARGET_NAMESPACE_PREFIX))
        {
            for(Iterator iter = _listOfBaseXSDFiles.iterator();iter.hasNext();)
            {
                String baseXsdFileName = (String) iter.next();
                if(!baseXsdFileName.equals(fileName))
                {
                    xsdRoot.appendChild(createXSDIncludeSchemaLocation(baseXsdFileName));
                }
            }
        }
        else if(_currentNamespacePrefix.equals(FIXM_DEFAULT_TARGET_NAMESPACE_PREFIX))
        {
            for(Iterator iter = _listOfFxXSDFiles.iterator();iter.hasNext();)
            {
                String baseFxFileName = (String) iter.next();
                if(!baseFxFileName.equals(fileName))
                {
                    xsdRoot.appendChild(createXSDIncludeSchemaLocation(baseFxFileName));
                }
            }
        }
        
        if(_currentNamespacePrefix.equals(FIXM_DEFAULT_TARGET_NAMESPACE_PREFIX))
        	xsdRoot.appendChild(createXSDImportBaseNamespace());
        
        if(_includeDocumentation)
            xsdRoot.appendChild(createXSDAnnotation(subPackage.GetNotes()));

        for (Iterator iter = subPackage.GetElements().iterator();iter.hasNext();)
        {
            org.w3c.dom.Element xsdElement = processElement((Element) iter.next());
            if(xsdElement != null)
                xsdRoot.appendChild(xsdElement);
        }
        
        if(xsdRoot != null)
        {                         
            _serializer.serialize(xsdRoot);
        } 
    }
    
    /**
     * 
     * @param myPackage
     * @throws IOException
     */
    public void generateFxXSDFile() throws IOException 
    {
        initXSDFile("./output/" + FIXM_DEFAULT_TARGET_NAMESPACE_PREFIX + "." + XSD_DEFAULT_TARGET_NAMESPACE_PREFIX);        
        org.w3c.dom.Element xsdRoot = createRootForFxXSDFile();
        
        for(Iterator iter = _listOfFxXSDFiles.iterator();iter.hasNext();)
        {
            xsdRoot.appendChild(createXSDIncludeSchemaLocation((String) iter.next()));
        }
        
        if(xsdRoot != null)
        {                         
            _serializer.serialize(xsdRoot);
        } 
    }
    
    /**
     * 
     * @param myPackage
     * @throws IOException
     */
    public void generateBaseXSDFile() throws IOException 
    {
        initXSDFile("./output/" + FIXM_BASE_TARGET_NAMESPACE_PREFIX + "." + XSD_DEFAULT_TARGET_NAMESPACE_PREFIX);        
        org.w3c.dom.Element xsdRoot = createRootForBaseXSDFile();
        
        for(Iterator iter = _listOfBaseXSDFiles.iterator();iter.hasNext();)
        {
            xsdRoot.appendChild(createXSDIncludeSchemaLocation((String) iter.next()));
        }
        
        if(xsdRoot != null)
        {                         
            _serializer.serialize(xsdRoot);
        } 
    }
    

    /**
     * 
     * @param myPackage
     * @return
     */
    protected org.w3c.dom.Element createRootForPackage(Package myPackage) {
        org.w3c.dom.Element root = super.createRoot();  
        
        root.setAttribute(XSD_XML_NAMESPACE + ":" + XSD_DEFAULT_TARGET_NAMESPACE_PREFIX, XSD_DEFAULT_TARGET_NAMESPACE);
        root.setAttribute(XSD_XML_NAMESPACE, XSD_DEFAULT_TARGET_NAMESPACE);
        root.setAttribute(XSD_XML_NAMESPACE + ":" + _currentNamespacePrefix, _currentNamespace);
        
        if(!myPackage.GetName().startsWith(FIXM_BASE_TARGET_NAMESPACE_PREFIX))
        {
            root.setAttribute(XSD_XML_NAMESPACE + ":" + FIXM_BASE_TARGET_NAMESPACE_PREFIX, FIXM_BASE_TARGET_NAMESPACE);
        }
        
        root.setAttribute("targetNamespace",_currentNamespace);
        root.setAttribute("elementFormDefault", _elementFormDefault);
        root.setAttribute("attributeFormDefault", _attributeFormDefault);
        root.setAttribute("version", myPackage.GetName() + ":" +  FIXM_DEFAULT_CORE_VERSION);
                
        return root;
    }


    /**
     * 
     * @return
     */
    protected org.w3c.dom.Element createRootForFxXSDFile() {
        org.w3c.dom.Element root = super.createRoot();
        
        root.setAttribute(XSD_XML_NAMESPACE + ":" + XSD_DEFAULT_TARGET_NAMESPACE_PREFIX, XSD_DEFAULT_TARGET_NAMESPACE);
        root.setAttribute(XSD_XML_NAMESPACE, XSD_DEFAULT_TARGET_NAMESPACE);
        root.setAttribute(XSD_XML_NAMESPACE + ":" + _targetNamespacePrefix, _targetNamespace);
        
        root.setAttribute("targetNamespace",_targetNamespace);
        root.setAttribute("elementFormDefault", _elementFormDefault);
        root.setAttribute("attributeFormDefault", _attributeFormDefault);
        root.setAttribute("version", FIXM_DEFAULT_CORE_VERSION);
         
        return root;
    }
    
    /**
     * 
     * @return
     */
    protected org.w3c.dom.Element createRootForBaseXSDFile() {
        org.w3c.dom.Element root = super.createRoot();
        
        root.setAttribute(XSD_XML_NAMESPACE + ":" + XSD_DEFAULT_TARGET_NAMESPACE_PREFIX, XSD_DEFAULT_TARGET_NAMESPACE);
        root.setAttribute(XSD_XML_NAMESPACE, XSD_DEFAULT_TARGET_NAMESPACE);
        root.setAttribute(XSD_XML_NAMESPACE + ":" + FIXM_BASE_TARGET_NAMESPACE_PREFIX, FIXM_BASE_TARGET_NAMESPACE);
        
        root.setAttribute("targetNamespace", FIXM_BASE_TARGET_NAMESPACE);
        root.setAttribute("elementFormDefault", "qualified");
        root.setAttribute("attributeFormDefault", "qualified");
        root.setAttribute("version", "base" + ":" + FIXM_DEFAULT_CORE_VERSION);
         
        return root;
    }
    
    
    /**
     * 
     * @return
     */
    protected org.w3c.dom.Element createXSDImportBaseNamespace()
    {
        org.w3c.dom.Element XSDimport = _xmldoc.createElement(XSD_TAG_IMPORT);
        XSDimport.setAttribute("namespace", FIXM_BASE_TARGET_NAMESPACE);
        XSDimport.setAttribute("schemaLocation", "./" + FIXM_BASE_TARGET_NAMESPACE_PREFIX + "." + XSD_DEFAULT_TARGET_NAMESPACE_PREFIX);
        return XSDimport;
    }
    
    /**
     * 
     * @param fixmClass
     * @return
     */
    protected org.w3c.dom.Element processEnumeration(Element fixmClass)
    {
        org.w3c.dom.Element simpleType = _xmldoc.createElement(XSD_TAG_SIMPLE_TYPE);
        
	    String name = fixmClass.GetName() + "Type";	  	    
	    simpleType.setAttribute("name",name);
	    
	    if(_includeDocumentation)
	        simpleType.appendChild(createXSDAnnotation(fixmClass.GetNotes()));
	    
        // Create the restriction base=xsd:string
        org.w3c.dom.Element restriction = _xmldoc.createElement(XSD_TAG_RESTRICTION);
        restriction.setAttribute("base", XSD_DEFAULT_TARGET_NAMESPACE_PREFIX + ":string");
        
        // Create the enumeration elements
        for (Iterator iter = fixmClass.GetAttributes().iterator();iter.hasNext();)
        {
            // each UML atribute maps to an XML enumeration element - except the other value, added by default to all codelist
            org.sparx.Attribute attribute = (org.sparx.Attribute)iter.next();

            org.w3c.dom.Element myEnum = _xmldoc.createElement(XSD_TAG_ENUMERATION);
            myEnum.setAttribute("value",attribute.GetName());
            //include annotation
            if(_includeDocumentation)
                myEnum.appendChild(createXSDAnnotation(attribute.GetNotes()));
            restriction.appendChild(myEnum);

        }
        
        simpleType.appendChild(restriction); 
	    
	    return simpleType; 
    }
    
    
    /**
     * 
     * @param element
     * @return
     */
    protected org.w3c.dom.Element processElement(Element fixmClass)
    {
        if(fixmClass.GetType().equals(EA_TYPE_CLASS) || fixmClass.GetType().equals(EA_TYPE_ENUMERATION))
        {
		    if(fixmClass.GetStereotype().equals(FIXM_STEREOTYPE_ENUMERATION))
		    {
		        return processEnumeration(fixmClass);
		    }
            else
            {
                return processFIXMClass(fixmClass);
            }
        }      
        return null;   
    }

    /**
     * 
     * @param element
     * @return
     */
    protected org.w3c.dom.Element processFIXMClass(Element fixmClass)
    {   
        EAEventManager.getInstance().fireEAEvent(this,"Processing " + SparxUtilities.toString(fixmClass));
        
        switch(getKindOfXSDType(fixmClass))
        {
        	case SIMPLE_TYPE:
        	    return createXSDSimpleType(fixmClass);        	   
        	case COMPLEX_TYPE_WITH_SIMPLE_CONTENT:
        	    return createXSDComplexTypeWithSimpleContent(fixmClass);        	    
        	case COMPLEX_TYPE_WITH_COMPLEX_CONTENT:
        	    return createXSDComplexTypeWithComplexContent(fixmClass);
        	case COMPLEX_TYPE_WITH_NO_CONTENT_AND_ATTRIBUTES:
        	    return createXSDComplexTypeWithNoContentAndAttibutes(fixmClass);
        	case COMPLEX_TYPE_WITH_NO_CONTENT_AND_ELEMENTS:
        	    return createXSDComplexTypeWithNoContentAndElements(fixmClass);
        }
        return null;
    }
    
    /////////////////////////////////////////////////////////////////////////////////
    // Methods used to create XSD 
    /////////////////////////////////////////////////////////////////////////////////
    
    /**
     * 
     * @param schema
     * @return
     */
    protected org.w3c.dom.Element createXSDIncludeSchemaLocation(String schema)
    {
        org.w3c.dom.Element XSDinclude = _xmldoc.createElement(XSD_TAG_INCLUDE);
        XSDinclude.setAttribute("schemaLocation", schema);   
        return XSDinclude;
    }
        
    /**
     * 
     * @param element
     * @return
     */
    protected org.w3c.dom.Element createXSDSimpleType(Element fixmClass)
    {
        String name = fixmClass.GetName();     
        Element UMLParent = getUMLParent(fixmClass);            
        String parentName = null;
        String namespacePrefix = null;

        
        parentName = UMLParent.GetName();
        namespacePrefix = getNamespacePrefixForElement(UMLParent);
        
        org.w3c.dom.Element simpleType = _xmldoc.createElement(XSD_TAG_SIMPLE_TYPE);  
        simpleType.setAttribute("name",name + "Type"); 
        
	    if(_includeDocumentation)
	        simpleType.appendChild(createXSDAnnotation(fixmClass.GetNotes()));
       
        // Create the restriction
        org.w3c.dom.Element restriction = _xmldoc.createElement(XSD_TAG_RESTRICTION);
	    
        if(isXSDSimpleType(UMLParent))
        {
            restriction.setAttribute("base",namespacePrefix + parentName);
        }
	    else
	    {
	        restriction.setAttribute("base",namespacePrefix + parentName + "Type");
	    }
	        
	    // Add xsd facet
        // Add any xsd facet value captured in Sprax EA tagged values
        for (Iterator iter = fixmClass.GetTaggedValues().iterator();iter.hasNext();)
        {
            TaggedValue taggedValue = (TaggedValue) iter.next();
            String taggedValueName = taggedValue.GetName();
            
            if(taggedValueName.equals("pattern") || taggedValueName.equals("minLength") || taggedValueName.equals("maxLength") || taggedValue.GetName().equals("minInclusive"))
            {
                org.w3c.dom.Element pattern = _xmldoc.createElement(taggedValueName);
                pattern.setAttribute("value",taggedValue.GetValue());
                restriction.appendChild(pattern);
            }
        }	   
	     	    
	    simpleType.appendChild(restriction);
	    
	    return simpleType;
    }
        
    /**
     * 
     * @param element
     * @return
     */
    protected org.w3c.dom.Element createXSDComplexTypeWithSimpleContent(Element fixmClass)
    {
        String name = fixmClass.GetName();     
        Element UMLParent = getUMLParent(fixmClass);            
        String parentName = null;
        String namespacePrefix = null;
        	
        org.w3c.dom.Element complexType = _xmldoc.createElement(XSD_TAG_COMPLEX_TYPE);
        complexType.setAttribute("name",name + "Type"); 
            
        if(_includeDocumentation)
            complexType.appendChild(createXSDAnnotation(fixmClass.GetNotes()));
    	    
        if(fixmClass.GetAbstract().equals("1"))
            complexType.setAttribute("abstract", "true");
    	    
	    org.w3c.dom.Element simpleContent = _xmldoc.createElement(XSD_TAG_SIMPLE_CONTENT);		   
	    org.w3c.dom.Element extension = _xmldoc.createElement(XSD_TAG_EXTENSION);
	    
        parentName = UMLParent.GetName();
        namespacePrefix = getNamespacePrefixForElement(UMLParent);
	    
        if(isXSDSimpleType(UMLParent))
            extension.setAttribute("base", getNamespacePrefixForElement(UMLParent) + parentName);
        else
            extension.setAttribute("base", getNamespacePrefixForElement(UMLParent) + parentName + "Type");
        
	    for (Iterator iter = fixmClass.GetAttributes().iterator(); iter.hasNext();)
	    {
	        Attribute umlAttribute = (Attribute) iter.next();
	        org.w3c.dom.Element attribute = _xmldoc.createElement(XSD_TAG_ATTRIBUTE);
	        attribute.setAttribute("name",umlAttribute.GetName());
	        
	        if(_includeDocumentation)
	            attribute.appendChild(createXSDAnnotation(umlAttribute.GetNotes()));

	        //Add type
            Element umlDatatype = null;
            try {
                umlDatatype = EAConnection.getInstance().getElementByID(umlAttribute.GetClassifierID());
            } catch (Exception e) {
                // Do nothing
            }
            if (umlDatatype != null) 
            {
                if(isXSDSimpleType(umlDatatype))
                    attribute.setAttribute("type",getNamespacePrefixForElement(umlDatatype)+ umlDatatype.GetName());
                   else
                       attribute.setAttribute("type",getNamespacePrefixForElement(umlDatatype)+ umlDatatype.GetName() + "Type");  
            }
            
            // Check UML attribute multiplicity 
            if(umlAttribute.GetLowerBound().equals("1") && umlAttribute.GetUpperBound().equals("1"))
                attribute.setAttribute("use","required");
            else if(umlAttribute.GetLowerBound().equals("0") && umlAttribute.GetUpperBound().equals("1"))
                attribute.setAttribute("use","optional");
            
	            extension.appendChild(attribute);
	    }

        simpleContent.appendChild(extension);
        complexType.appendChild(simpleContent);
    
        return complexType;
    }
        
    /**
     * 
     * @param element
     * @return
     */
    protected org.w3c.dom.Element createXSDComplexTypeWithComplexContent(Element fixmClass)
    {
        String name = fixmClass.GetName();     
        Element UMLParent = getUMLParent(fixmClass);            
        String parentName = null;
        String namespacePrefix = null;
        	
        org.w3c.dom.Element complexType = _xmldoc.createElement(XSD_TAG_COMPLEX_TYPE);
        complexType.setAttribute("name",name + "Type"); 
            
        if(_includeDocumentation)
            complexType.appendChild(createXSDAnnotation(fixmClass.GetNotes()));
    	    
        if(fixmClass.GetAbstract().equals("1"))
            complexType.setAttribute("abstract", "true");
        
        
        org.w3c.dom.Element complexContent = _xmldoc.createElement(XSD_TAG_COMPLEX_CONTENT);		   
        org.w3c.dom.Element extension = _xmldoc.createElement(XSD_TAG_EXTENSION);
		    
        parentName = UMLParent.GetName();
        namespacePrefix = getNamespacePrefixForElement(UMLParent);
            
        if(isXSDSimpleType(UMLParent))
            extension.setAttribute("base", getNamespacePrefixForElement(UMLParent) + parentName);
        else
            extension.setAttribute("base", getNamespacePrefixForElement(UMLParent) + parentName + "Type");
        
        org.w3c.dom.Element sequence = _xmldoc.createElement(XSD_TAG_SEQUENCE);
		    
        for (Iterator iter = fixmClass.GetAttributes().iterator(); iter.hasNext();)
        {
	        Attribute umlAttribute = (Attribute) iter.next();
	        //Get type
            Element umlDatatype = null;
            try {
                umlDatatype = EAConnection.getInstance().getElementByID(umlAttribute.GetClassifierID());
            } catch (Exception e) {
                // Do nothing
            }
            
	        org.w3c.dom.Element element = _xmldoc.createElement(XSD_TAG_ELEMENT);
	        element.setAttribute("name",umlAttribute.GetName());
	        if(_includeDocumentation)
	            element.appendChild(createXSDAnnotation(umlAttribute.GetNotes()));
            
            if (umlDatatype != null) 
            {
                if(isXSDSimpleType(umlDatatype))
                    element.setAttribute("type",getNamespacePrefixForElement(umlDatatype)+ umlDatatype.GetName());
                else
                    element.setAttribute("type",getNamespacePrefixForElement(umlDatatype)+ umlDatatype.GetName() + "Type");        	    	        
            }
            
            // Check UML attribute multiplicity 
            if(umlAttribute.GetLowerBound().equals("0"))
                element.setAttribute("minOccurs","0");
            
            sequence.appendChild(element);	        
	    }
	    extension.appendChild(sequence);
        complexContent.appendChild(extension);
        complexType.appendChild(complexContent);

        return complexType;
    }
        
    /**
     * 
     * @param element
     * @return
     */
    protected org.w3c.dom.Element createXSDComplexTypeWithNoContentAndAttibutes(Element fixmClass)
    {
        String name = fixmClass.GetName();     
        Element UMLParent = getUMLParent(fixmClass);            
        String parentName = null;
        String namespacePrefix = null;
        	
        org.w3c.dom.Element complexType = _xmldoc.createElement(XSD_TAG_COMPLEX_TYPE);
        complexType.setAttribute("name",name + "Type"); 
            
        if(_includeDocumentation)
            complexType.appendChild(createXSDAnnotation(fixmClass.GetNotes()));
    	    
        if(fixmClass.GetAbstract().equals("1"))
            complexType.setAttribute("abstract", "true");
        
        
        org.w3c.dom.Element sequence = _xmldoc.createElement(XSD_TAG_SEQUENCE);
        complexType.appendChild(sequence);
        
	    for (Iterator iter = fixmClass.GetAttributes().iterator(); iter.hasNext();)
	    {
	        Attribute umlAttribute = (Attribute) iter.next();
	        org.w3c.dom.Element attribute = _xmldoc.createElement(XSD_TAG_ATTRIBUTE);
	        attribute.setAttribute("name",umlAttribute.GetName());
	        
	        if(_includeDocumentation)
	            attribute.appendChild(createXSDAnnotation(umlAttribute.GetNotes()));

	        //Add type
            Element umlDatatype = null;
            try {
                umlDatatype = EAConnection.getInstance().getElementByID(umlAttribute.GetClassifierID());
            } catch (Exception e) {
                // Do nothing
            }
            if (umlDatatype != null) 
            {
                if(isXSDSimpleType(umlDatatype))//,"{B4B4F82F-2CF3-4b84-84A0-6C527442A244}"))
                    attribute.setAttribute("type",getNamespacePrefixForElement(umlDatatype)+ umlDatatype.GetName());
                else
                    attribute.setAttribute("type",getNamespacePrefixForElement(umlDatatype)+ umlDatatype.GetName() + "Type");  
            }
            
            // Check UML attribute multiplicity 
            if(umlAttribute.GetLowerBound().equals("1") && umlAttribute.GetUpperBound().equals("1"))
                attribute.setAttribute("use","required");
            else if(umlAttribute.GetLowerBound().equals("0") && umlAttribute.GetUpperBound().equals("1"))
                attribute.setAttribute("use","optional");
            
            complexType.appendChild(attribute);
	    }

	    return complexType;
    }
            
    
    /**
     * 
     * @param element
     * @return
     */
    protected org.w3c.dom.Element createXSDComplexTypeWithNoContentAndElements(Element fixmClass)
    {
        String name = fixmClass.GetName();     
        Element UMLParent = getUMLParent(fixmClass);            
        String parentName = null;
        String namespacePrefix = null;
        	
        org.w3c.dom.Element complexType = _xmldoc.createElement(XSD_TAG_COMPLEX_TYPE);
        complexType.setAttribute("name",name + "Type"); 
            
        if(_includeDocumentation)
            complexType.appendChild(createXSDAnnotation(fixmClass.GetNotes()));
    	    
        if(fixmClass.GetAbstract().equals("1"))
            complexType.setAttribute("abstract", "true");
        
        
        org.w3c.dom.Element sequence = _xmldoc.createElement(XSD_TAG_SEQUENCE);
        complexType.appendChild(sequence);
        
	    for (Iterator iter = fixmClass.GetAttributes().iterator(); iter.hasNext();)
	    {
	        Attribute umlAttribute = (Attribute) iter.next();
	        org.w3c.dom.Element element = _xmldoc.createElement(XSD_TAG_ELEMENT);
	        element.setAttribute("name",umlAttribute.GetName());
	        
	        if(_includeDocumentation)
	            element.appendChild(createXSDAnnotation(umlAttribute.GetNotes()));

	        //Add type
            Element umlDatatype = null;
            try {
                umlDatatype = EAConnection.getInstance().getElementByID(umlAttribute.GetClassifierID());
            } catch (Exception e) {
                // Do nothing
            }
            if (umlDatatype != null) 
            {
                if(isXSDSimpleType(umlDatatype))//,"{B4B4F82F-2CF3-4b84-84A0-6C527442A244}"))
                    element.setAttribute("type",getNamespacePrefixForElement(umlDatatype)+ umlDatatype.GetName());
                else
                    element.setAttribute("type",getNamespacePrefixForElement(umlDatatype)+ umlDatatype.GetName() + "Type");  
            }
            
            // Check UML attribute multiplicity 
            if(umlAttribute.GetLowerBound().equals("1") && umlAttribute.GetUpperBound().equals("1"))
                element.setAttribute("minOccurs","1");
            else if(umlAttribute.GetLowerBound().equals("0") && umlAttribute.GetUpperBound().equals("1"))
                element.setAttribute("minOccurs","0");
            
            
            sequence.appendChild(element);
	    }

	    return complexType;
    }
    
    

    /////////////////////////////////////////////////////////////////////////////////
    // 
    /////////////////////////////////////////////////////////////////////////////////    
    
    
    /**
     * 
     * @param element
     * @return
     */
    protected String getNamespacePrefixForElement(Element element) {
        
        Package myPackage = EAConnection.getInstance().getRepository().GetPackageByID(element.GetPackageID());
        String namespace = null;
        
        if(myPackage!=null)
        {
            if(SparxUtilities.belongsToPackage(myPackage, FIXM_GUID_PACKAGE_BASE))//"{D021BC90-BAF1-4f5b-A5E7-EA22173DEA00}"))
            {
                return FIXM_BASE_TARGET_NAMESPACE_PREFIX + ":";                
            }                
            else if (SparxUtilities.belongsToPackage(myPackage, FIXM_GUID_PACKAGE_CORE))//"{D7A4A9D5-11C3-4706-8D89-74C27C53664D}"))
            {
                return FIXM_DEFAULT_TARGET_NAMESPACE_PREFIX + ":";
            }
            else if (isXSDSimpleType(element))//SparxUtilities.belongsToPackage(myPackage, "{B4B4F82F-2CF3-4b84-84A0-6C527442A244}"))
                return XSD_DEFAULT_TARGET_NAMESPACE_PREFIX + ":";
        }
        return XSD_DEFAULT_TARGET_NAMESPACE_PREFIX + ":";
    }
    
    
    /**
     * 
     * @return
     */
    protected int getKindOfXSDType(Element fixmClass)
    {   
		// XML Schema divides types into two kinds: 
		// - complex types, which allow element content and/or attributes;
		// - simple types, which don't. 
		//
		// XML Schema then splits complex types (which allow attributes) into two classes: 
		// - those with purely textual content (simple content)
		// - those with element content (complex content). 
	    //
		//        Type
		//        /\
		//       /  \
		//      /    \
		// Simple    Complex           allows attributes or elements?
		//  Type      Type
		//             /\
		//            /  \
		//           /    \
		//       Simple  Complex       allows elements in content?
		//      Content  Content
        
        Element UMLParent = getUMLParent(fixmClass);
        
        /////////////////////////////////////
        // Default cases
        /////////////////////////////////////
        if(isXSDSimpleType(fixmClass))
        {
            return SIMPLE_TYPE;
        }
            
        // If the class is an enumeration, it maps to a simpleType
        if(fixmClass.GetStereotype().equals(FIXM_STEREOTYPE_ENUMERATION))//"enumeration"))
        {
            return SIMPLE_TYPE;
        }       
        
        // Process abstract class
        if(fixmClass.GetAbstract().equals("1"))
        {
            if(!(UMLParent != null && getKindOfXSDType(UMLParent) != SIMPLE_TYPE))    
            {
                short kindOfXSDTypeForProperties = getKindOfXSDTypeForProperties(fixmClass);
                if(kindOfXSDTypeForProperties!= -1 && kindOfXSDTypeForProperties != SIMPLE_TYPE)
                    return COMPLEX_TYPE_WITH_NO_CONTENT_AND_ELEMENTS;
                
                return COMPLEX_TYPE_WITH_NO_CONTENT_AND_ATTRIBUTES;
            }
            if(fixmClass.GetName().equals("AbstractExtension"))
                return COMPLEX_TYPE_WITH_COMPLEX_CONTENT;
        }
        
        // Process abstract class
        if(UMLParent == null && getUMLPropertyCount(fixmClass) > 0)
        {
            short kindOfXSDTypeForProperties = getKindOfXSDTypeForProperties(fixmClass);
            if(kindOfXSDTypeForProperties!= -1 && kindOfXSDTypeForProperties != SIMPLE_TYPE)
                return COMPLEX_TYPE_WITH_NO_CONTENT_AND_ELEMENTS;
            
            return COMPLEX_TYPE_WITH_NO_CONTENT_AND_ATTRIBUTES;
        }
        
        /////////////////////////////////////
        // Simple or Complex type ?
        /////////////////////////////////////
        boolean complexContent = false;  
        
        if(UMLParent != null && getKindOfXSDType(UMLParent)!=SIMPLE_TYPE)
            complexContent = true;
       
        if(getUMLPropertyCount(fixmClass)>0)
            complexContent = true;
                
        if(!complexContent)
        {
            return SIMPLE_TYPE;
        }
        else
        {
            ///////////////////////////////////////////
            // simple or complex content ?
            ///////////////////////////////////////////
            short kindOfXSDTypeForProperties = getKindOfXSDTypeForProperties(fixmClass);
            if(kindOfXSDTypeForProperties != -1)
                return kindOfXSDTypeForProperties;
            
            if(UMLParent != null && (getKindOfXSDType(UMLParent) == COMPLEX_TYPE_WITH_COMPLEX_CONTENT || getKindOfXSDType(UMLParent) == COMPLEX_TYPE_WITH_NO_CONTENT_AND_ATTRIBUTES) )
                return COMPLEX_TYPE_WITH_COMPLEX_CONTENT;
            
            
            return COMPLEX_TYPE_WITH_SIMPLE_CONTENT;
        }
    }
    
    
    /**
     * 
     * @param fixmClass
     * @return
     */
    protected short getUMLPropertyCount(Element fixmClass)
    {
        short attributeCount = fixmClass.GetAttributes().GetCount();
        short roleCount = 0;
        
        for (Iterator iter = fixmClass.GetConnectors().iterator();iter.hasNext();)
        {
	        Connector connector = (Connector) iter.next();
	        String connectorType = connector.GetType();

	        if(connectorType.equals(EA_CONNECTOR_TYPE_ASSOCIATION) || connectorType.equals(EA_CONNECTOR_TYPE_AGGREGATION))
	        {	            
	            int id = connector.GetClientID();
	            String roleName = connector.GetClientEnd().GetRole();           
	            
	            // Note: depending on the way the UML association was modelled, what is called the target class in the comment above can be either the "client" or "supplier" of the connector.
	            // The purpose of this piece of code is to make sure the right target association is correctly processed.                                
	            if (id == fixmClass.GetElementID())
	            {
	                id = connector.GetSupplierID();
	                roleName = connector.GetSupplierEnd().GetRole();
	            }
	            if(roleName.length()>0)
	                roleCount++;
	        }
        }
        
        return (short) (attributeCount + roleCount);
    }
    
    /**
     * 
     * @param fixmClass
     * @return
     */
    protected short getKindOfXSDTypeForProperties(Element fixmClass)
    {
        // Process attributes
        for (Iterator iter = fixmClass.GetAttributes().iterator();iter.hasNext();)
	    {
	        Attribute umlAttribute = (Attribute)iter.next();
	        Element umlDatatype = null;
	        try
	        {
	            umlDatatype = EAConnection.getInstance().getElementByID(umlAttribute.GetClassifierID());
	            if (getKindOfXSDType(umlDatatype) != SIMPLE_TYPE)
	            {
	                return COMPLEX_TYPE_WITH_COMPLEX_CONTENT;
	            }
	        }
	        catch(Exception e)
	        {
	            EAEventManager.getInstance().fireEAEvent(this,MESSAGE_ERROR + ": " + "attribute badly typed : " + SparxUtilities.toString(umlAttribute,fixmClass));
	        }
	    }
        
        // Process connectors
        for (Iterator iter = fixmClass.GetConnectors().iterator();iter.hasNext();)
        {
	        Connector connector = (Connector) iter.next();
	        String connectorType = connector.GetType();

	        if(connectorType.equals(EA_CONNECTOR_TYPE_ASSOCIATION) || connectorType.equals(EA_CONNECTOR_TYPE_AGGREGATION))
	        {	            
	            int id = connector.GetClientID();
	            String roleName = connector.GetClientEnd().GetRole();           
	            
	            // Note: depending on the way the UML association was modelled, what is called the target class in the comment above can be either the "client" or "supplier" of the connector.
	            // The purpose of this piece of code is to make sure the right target association is correctly processed.                                
	            if (id == fixmClass.GetElementID())
	            {
	                id = connector.GetSupplierID();
	                roleName = connector.GetSupplierEnd().GetRole();
	            }
	            // a blank role name means no property
	            if(roleName.length()>0)
	            {
	                Element associatedElement = EAConnection.getInstance().getRepository().GetElementByID(id);
	                if(associatedElement != null)
	                {   	                   
	    	            if (getKindOfXSDType(associatedElement) != SIMPLE_TYPE)
	    	            {
	    	                return COMPLEX_TYPE_WITH_COMPLEX_CONTENT;
	    	            }
	                }
	            }
	        }
        }       
        return -1;
    }
    
    /**
     * 
     * @param fixmElement
     * @return
     */
    protected boolean isXSDSimpleType(Element element)
    {
        return SparxUtilities.belongsToPackage(element, FIXM_GUID_PACKAGE_XSD_SCHEMA_DATATYPES);
    }
}
